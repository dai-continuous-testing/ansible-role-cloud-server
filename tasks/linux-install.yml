
# validation

- name: assert all vars are set
  assert: 
    that:
      - item is defined
      - item | length > 0
    quiet: true
  loop:
  - app_name
  - clear_temp_folder
  - service_name
  - main_class
  - installation_folder
  - clear_before_install
  - server_port
  - service_file_path
  - installer_file_name
  - ansible_user_id
  - s3_download_url
  - launcher_file_name
  - db_connection_string
  - db_username
  # - db_password
  - application_properties
  - xml_conf
  - extra_java_options
  - logs_folder


# set temp folder

- name: make sure temp folder
  file:
    path: "{{ temp_folder }}"
    state: directory
    owner: "{{ ansible_user_id }}"
  become: yes
  
# required java dependency

- name: make sure java is installed on the machine
  command: "{{ java_home }}/bin/java -version"
  register: java_test
  become: yes
  ignore_errors: yes

- name: fail if java is not found
  fail:
    msg: "java must be accesible in path {{ java_home }}/bin/java"
  when: java_test.rc != 0

# download the file
- name: download zip from s3 url
  get_url:
    url: "{{ s3_download_url }}"
    dest: "{{ temp_folder }}/{{ installer_file_name }}"
    timeout: "{{ download_timeout | default(60) }}"
  when: custom_download_url == ""

- name: download zip from custom url
  get_url:
    url: "{{ custom_download_url }}"
    dest: "{{ temp_folder }}/{{ installer_file_name }}"
    timeout: "{{ download_timeout | default(60) }}"
  when: custom_download_url != ""

# delete old installation (optional)

- name: clear old installation folder
  file: 
    path: "{{ installation_folder }}"
    state: absent
  when: clear_before_install == True

# unpack and copy all the files to the installation folder

- name: make sure installation folder exists
  file:
    path: "{{ installation_folder }}"
    state: directory
    owner: "{{ ansible_user_id }}"
  become: yes

- name: make sure unzip folder exist
  file:
    path: "{{ temp_folder }}/{{ (installer_file_name | splitext)[0] }}"
    state: directory
    owner: "{{ ansible_user_id }}"
  become: yes

# REMOVEME ugly hack - remove the sub folder in zip file
- name: unzip the file
  unarchive:
    src: "{{ temp_folder }}/{{ installer_file_name }}"
    dest: "{{ temp_folder }}/{{ (installer_file_name | splitext)[0] }}"
    remote_src: yes
    creates: "{{ temp_folder }}/{{ (installer_file_name | splitext)[0] }}/{{ convention }}"
    owner: "{{ ansible_user_id }}"
  become: yes

- name: synchronize zip content to installation folder
  command: "rsync -r {{ temp_folder }}/{{ (installer_file_name | splitext)[0] }}/{{ convention }}/ {{ installation_folder }}/"
  become: yes
  # notify:
  #   - start the service

- name: make sure launcher file exists
  file:
    path: "{{ installation_folder }}/bin/{{ launcher_file_name }}"
    mode: 0777
    owner: "{{ ansible_user_id }}"
  become: yes

# configure installed 

- name: update application properties file
  dai_continuous_testing.utilities.application_properties:
    path: "{{ installation_folder }}/conf/application.properties"
    properties: "{{ application_properties }}"
    backup: yes
    comment_existing: yes
    marker: "ANSIBLE MANAGED BLOCK - Application Properties"
  become: yes

- name: verify application properties file exists
  stat:
    path: "{{ installation_folder }}/conf/application.properties"
  register: app_properties_file_stat
  become: yes

- name: ensure application properties file is accessible
  assert:
    that:
      - app_properties_file_stat.stat.exists
      - app_properties_file_stat.stat.readable
    fail_msg: "Application properties file not found or not readable"
    success_msg: "Application properties file successfully created/updated"

- name: update logback properties file
  dai_continuous_testing.utilities.application_properties:
    path: "{{ installation_folder }}/conf/logback.properties"
    properties: "{{ logback_properties }}"
    backup: yes
    comment_existing: yes
    marker: "ANSIBLE MANAGED BLOCK - Logback Properties"
  become: yes

- name: verify logback properties file exists
  stat:
    path: "{{ installation_folder }}/conf/logback.properties"
  register: logback_properties_file_stat
  become: yes

- name: ensure logback properties file is accessible
  assert:
    that:
      - logback_properties_file_stat.stat.exists
      - logback_properties_file_stat.stat.readable
    fail_msg: "Logback properties file not found or not readable"
    success_msg: "Logback properties file successfully created/updated"

- name: update xml conf
  lineinfile:
    state: present
    path: "{{ installation_folder }}/conf/cloudserver.conf.xml"
    line: "<{{ item.key }}>{{ item.value }}</{{ item.key }}>"
    regexp: "<{{ item.key }}>.*<\\/{{ item.key }}>"
    insertbefore:  "<\\/forwarder-configuration>"
  with_dict: "{{ xml_conf }}"
  become: yes

- name: make sure logs folder exists
  file:
    path: "{{ logs_folder }}"
    state: directory
    mode: 0777
    owner: "{{ ansible_user_id }}"
  become: yes

- name: remove existing logs folder from installation folder
  file:
    path: "{{ installation_folder }}/logs"
    state: absent
  become: yes

# set permission to zipalign file

- name: check the zipalign file exists
  stat:
    path: "{{ installation_folder }}/bin/adb/js/linux/zipalign"
  register: zipalign_exists

- name: set permissions to zipalign file
  file:
    path: "{{ installation_folder }}/bin/adb/js/linux/zipalign"
    state: file
    mode: 0777
  become: yes
  when: zipalign_exists.stat.exists

# QUESTION should remove pairing key for cloud ?

# - name: reset pairing key
#   file:
#     path: "{{ installation_folder }}/conf/pairing.conf.xml"
#     state: absent
#   become: yes

# remove vmoptions file

- name: check vmoptions files to remove
  find:
    paths: "{{ installation_folder }}"
    file_type: file
    patterns: "*.vmoptions"
  register: delete_vmoptions
  become: yes

- name: remove vmoptions files from installation folder
  file:
    path: "{{ item.path }}"
    state: absent
  become: yes
  with_items:
    - "{{ delete_vmoptions.files }}"

# Health check after installation  
- name: verify cloud server health after installation
  dai_continuous_testing.utilities.health_check:
    url: "http://localhost:{{ server_port }}{{ health_check_uri | default('/manage/health') }}"
    expected_status: 200
    timeout: 30
    max_retries: 15
    delay_between_tries: 10
    initial_delay: 30
    headers:
      Accept: "application/json"
      User-Agent: "Ansible-CloudServer-HealthCheck"
  register: cloudserver_health_check
  when: start_after_install | default(true)
  ignore_errors: yes

- name: verify cloud server prometheus metrics endpoint
  dai_continuous_testing.utilities.health_check:
    url: "http://localhost:{{ management_port | default('33300') }}/manage/prometheus"
    expected_status: 200
    timeout: 15
    max_retries: 5
    delay_between_tries: 3
  register: cloudserver_metrics_check
  when: 
    - start_after_install | default(true)
    - cloudserver_health_check.success | default(false)
  ignore_errors: yes

- name: display comprehensive health check results
  debug:
    msg: |
      Cloud Server Health Check Results:
      =====================================
      Main Health Check:
        Status: {{ 'PASSED' if cloudserver_health_check.success | default(false) else 'FAILED' }}
        URL: {{ cloudserver_health_check.url | default('N/A') }}
        Message: {{ cloudserver_health_check.msg | default('Health check was not performed') }}
        Attempts: {{ cloudserver_health_check.failed_attempts | default(0) + 1 if cloudserver_health_check.failed_attempts is defined else 'N/A' }}
      
      Prometheus Metrics Check:
        Status: {{ 'PASSED' if cloudserver_metrics_check.success | default(false) else 'SKIPPED/FAILED' }}
        URL: {{ cloudserver_metrics_check.url | default('N/A') }}
        Message: {{ cloudserver_metrics_check.msg | default('Metrics check was not performed') }}
  when: cloudserver_health_check is defined


